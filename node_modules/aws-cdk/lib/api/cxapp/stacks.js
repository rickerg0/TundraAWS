"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const region_info_1 = require("@aws-cdk/region-info");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const arrays_1 = require("../../util/arrays");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * If no selectors are provided, returns all stacks in the app.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection = exports.DefaultSelection || (exports.DefaultSelection = {}));
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
class AppStacks {
    constructor(props) {
        this.props = props;
    }
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    async selectStacks(selectors, options) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = await this.listStacks();
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            switch (options.defaultBehavior) {
                case DefaultSelection.AllStacks:
                    return stacks;
                case DefaultSelection.None:
                    return [];
                case DefaultSelection.OnlySingle:
                    if (stacks.length === 1) {
                        return stacks;
                    }
                    else {
                        throw new Error(`Since this app includes more than a single stack, specify which stacks to use (wildcards are supported)\n` +
                            `Stacks: ${stacks.map(x => x.name).join(' ')}`);
                    }
                default:
                    throw new Error(`invalid default behavior: ${options.defaultBehavior}`);
            }
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.name, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.name, pattern) && !selectedStacks.has(stack.name)) {
                    selectedStacks.set(stack.name, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        const extend = options.extend || ExtendedStackSelection.None;
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.name));
        return selectedList;
    }
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     */
    async listStacks() {
        const response = await this.synthesizeStacks();
        return response.stacks;
    }
    /**
     * Synthesize a single stack
     */
    async synthesizeStack(stackName) {
        const resp = await this.synthesizeStacks();
        const stack = resp.getStack(stackName);
        return stack;
    }
    /**
     * Synthesize a set of stacks
     */
    async synthesizeStacks() {
        if (this.assembly) {
            return this.assembly;
        }
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.aws, this.props.configuration);
            if (assembly.manifest.missing) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    logging_1.debug(`Not making progress trying to resolve environmental context. Giving up.`);
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    logging_1.debug(`Some context information is missing. Fetching...`);
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.aws);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            if (trackVersions && assembly.runtime) {
                const modules = formatModules(assembly.runtime);
                for (const stack of assembly.stacks) {
                    if (!stack.template.Resources) {
                        stack.template.Resources = {};
                    }
                    const resourcePresent = stack.environment.region === cxapi.UNKNOWN_REGION
                        || region_info_1.RegionInfo.get(stack.environment.region).cdkMetadataResourceAvailable;
                    if (resourcePresent) {
                        if (!stack.template.Resources.CDKMetadata) {
                            stack.template.Resources.CDKMetadata = {
                                Type: 'AWS::CDK::Metadata',
                                Properties: {
                                    Modules: modules
                                }
                            };
                            if (stack.environment.region === cxapi.UNKNOWN_REGION) {
                                stack.template.Conditions = stack.template.Conditions || {};
                                const condName = 'CDKMetadataAvailable';
                                if (!stack.template.Conditions[condName]) {
                                    stack.template.Conditions[condName] = _makeCdkMetadataAvailableCondition();
                                    stack.template.Resources.CDKMetadata.Condition = condName;
                                }
                                else {
                                    logging_1.warning(`The stack ${stack.name} already includes a ${condName} condition`);
                                }
                            }
                        }
                        else {
                            logging_1.warning(`The stack ${stack.name} already includes a CDKMetadata resource`);
                        }
                    }
                }
            }
            // All good, return
            this.assembly = assembly;
            return assembly;
            function formatModules(runtime) {
                const modules = new Array();
                // inject toolkit version to list of modules
                const toolkitVersion = require('../../../package.json').version;
                modules.push(`aws-cdk=${toolkitVersion}`);
                for (const key of Object.keys(runtime.libraries).sort()) {
                    modules.push(`${key}=${runtime.libraries[key]}`);
                }
                return modules.join(',');
            }
        }
    }
    /**
     * @returns an array with the tags available in the stack metadata.
     */
    getTagsFromStackMetadata(stack) {
        return arrays_1.flatMap(stack.findMetadataByType(cxapi.STACK_TAGS_METADATA_KEY), x => x.data);
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadata(stacks) {
        let warnings = false;
        let errors = false;
        for (const stack of stacks) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cxapi.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        this.printMessage(logging_1.warning, 'Warning', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.ERROR:
                        errors = true;
                        this.printMessage(logging_1.error, 'Error', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.INFO:
                        this.printMessage(logging_1.print, 'Info', message.id, message.entry);
                        break;
                }
            }
        }
        if (errors && !this.props.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (this.props.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
    }
    printMessage(logFn, prefix, id, entry) {
        logFn(`[${prefix} at ${id}] ${entry.data}`);
        if (this.props.verbose && entry.trace) {
            logFn(`  ${entry.trace.join('\n  ')}`);
        }
    }
}
exports.AppStacks = AppStacks;
/**
 * Combine the names of a set of stacks using a comma
 */
function listStackNames(stacks) {
    return stacks.map(s => s.name).join(', ');
}
exports.listStackNames = listStackNames;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * Include stacks that depend on the stacks already in the set
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const [name, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(name) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(name, stack);
                added.push(name);
                madeProgress = true;
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Include stacks that that stacks in the set depend on
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyName of stack.dependencies.map(x => x.id)) {
                if (!selectedStacks.has(dependencyName) && allStacks.has(dependencyName)) {
                    added.push(dependencyName);
                    selectedStacks.set(dependencyName, allStacks.get(dependencyName));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Return all keys of misisng context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
function _makeCdkMetadataAvailableCondition() {
    return _fnOr(region_info_1.RegionInfo.regions
        .filter(ri => ri.cdkMetadataResourceAvailable)
        .map(ri => ({ 'Fn::Equals': [{ Ref: 'AWS::Region' }, ri.name] })));
}
/**
 * This takes a bunch of operands and crafts an `Fn::Or` for those. Funny thing is `Fn::Or` requires
 * at least 2 operands and at most 10 operands, so we have to... do this.
 */
function _fnOr(operands) {
    if (operands.length === 0) {
        throw new Error('Cannot build `Fn::Or` with zero operands!');
    }
    if (operands.length === 1) {
        return operands[0];
    }
    if (operands.length <= 10) {
        return { 'Fn::Or': operands };
    }
    return _fnOr(_inGroupsOf(operands, 10).map(group => _fnOr(group)));
}
function _inGroupsOf(array, maxGroup) {
    const result = new Array();
    for (let i = 0; i < array.length; i += maxGroup) {
        result.push(array.slice(i, i + maxGroup));
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLHNEQUFrRDtBQUNsRCxzQ0FBdUM7QUFDdkMsdUNBQXdDO0FBQ3hDLDREQUE2RDtBQUM3RCwyQ0FBNkQ7QUFFN0QsOENBQTRDO0FBMkQ1QyxJQUFZLGdCQWdCWDtBQWhCRCxXQUFZLGdCQUFnQjtJQUMxQjs7T0FFRztJQUNILGlDQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx5Q0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILHFDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFoQlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFnQjNCO0FBRUQ7Ozs7R0FJRztBQUNILE1BQWEsU0FBUztJQVFwQixZQUE2QixLQUFxQjtRQUFyQixVQUFLLEdBQUwsS0FBSyxDQUFnQjtJQUFHLENBQUM7SUFFdEQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsT0FBNEI7UUFDekUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFdEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzFCLFFBQVEsT0FBTyxDQUFDLGVBQWUsRUFBRTtnQkFDL0IsS0FBSyxnQkFBZ0IsQ0FBQyxTQUFTO29CQUM3QixPQUFPLE1BQU0sQ0FBQztnQkFDaEIsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJO29CQUN4QixP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QUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsS0FBSyxDQUFDLFFBQWU7SUFDNUIsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7S0FDOUQ7SUFDRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEVBQUUsRUFBRTtRQUN6QixPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDO0tBQy9CO0lBQ0QsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBSSxLQUFVLEVBQUUsUUFBZ0I7SUFDbEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQU8sQ0FBQztJQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksUUFBUSxFQUFFO1FBQy9DLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7S0FDM0M7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN4YXBpID0gcmVxdWlyZSgnQGF3cy1jZGsvY3gtYXBpJyk7XG5pbXBvcnQgeyBSZWdpb25JbmZvIH0gZnJvbSAnQGF3cy1jZGsvcmVnaW9uLWluZm8nO1xuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5pbXBvcnQgY29udGV4dHByb3ZpZGVycyA9IHJlcXVpcmUoJy4uLy4uL2NvbnRleHQtcHJvdmlkZXJzJyk7XG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IsIHByaW50LCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgZmxhdE1hcCB9IGZyb20gJy4uLy4uL3V0aWwvYXJyYXlzJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi91dGlsL3Nkayc7XG5cbi8qKlxuICogQHJldHVybnMgb3V0cHV0IGRpcmVjdG9yeVxuICovXG50eXBlIFN5bnRoZXNpemVyID0gKGF3czogSVNESywgY29uZmlnOiBDb25maWd1cmF0aW9uKSA9PiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFwcFN0YWNrc1Byb3BzIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYmUgdmVyYm9zZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERvbid0IHN0b3Agb24gZXJyb3IgbWV0YWRhdGFcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZUVycm9ycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyZWF0IHdhcm5pbmdzIGluIG1ldGFkYXRhIGFzIGVycm9yc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc3RyaWN0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBhd3M6IElTREs7XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgdG8gc3ludGhlc2l6ZSB0aGUgYWN0dWFsIHN0YWNrc1xuICAgKi9cbiAgc3ludGhlc2l6ZXI6IFN5bnRoZXNpemVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFN0YWNrc09wdGlvbnMge1xuICAvKipcbiAgICogRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdXBzdHJlYWQvZG93bnN0cmVhbSBzdGFja3NcbiAgICogQGRlZmF1bHQgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIG9ubHkgc2VsZWN0IHRoZSBzcGVjaWZpZWQgc3RhY2tzLlxuICAgKi9cbiAgZXh0ZW5kPzogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGJlaGF2aW9yIGlmIGlmIG5vIHNlbGVjdG9ycyBhcmUgcHJpdmlkZWQuXG4gICAqL1xuICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb247XG59XG5cbmV4cG9ydCBlbnVtIERlZmF1bHRTZWxlY3Rpb24ge1xuICAvKipcbiAgICogUmV0dXJucyBhbiBlbXB0eSBzZWxlY3Rpb24gaW4gY2FzZSB0aGVyZSBhcmUgbm8gc2VsZWN0b3JzLlxuICAgKi9cbiAgTm9uZSA9ICdub25lJyxcblxuICAvKipcbiAgICogSWYgdGhlIGFwcCBpbmNsdWRlcyBhIHNpbmdsZSBzdGFjaywgcmV0dXJucyBpdC4gT3RoZXJ3aXNlIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAqIFRoaXMgYmVoYXZpb3IgaXMgdXNlZCBieSBcImRlcGxveVwiLlxuICAgKi9cbiAgT25seVNpbmdsZSA9ICdzaW5nbGUnLFxuXG4gIC8qKlxuICAgKiBJZiBubyBzZWxlY3RvcnMgYXJlIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBzdGFja3MgaW4gdGhlIGFwcC5cbiAgICovXG4gIEFsbFN0YWNrcyA9ICdhbGwnLFxufVxuXG4vKipcbiAqIFJvdXRpbmVzIHRvIGdldCBzdGFja3MgZnJvbSBhbiBhcHBcbiAqXG4gKiBJbiBhIGNsYXNzIGJlY2F1c2UgaXQgc2hhcmVzIHNvbWUgZ2xvYmFsIHN0YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcHBTdGFja3Mge1xuXG4gIC8qKlxuICAgKiBTaW5jZSBhcHAgZXhlY3V0aW9uIGJhc2ljYWxseSBhbHdheXMgc3ludGhlc2l6ZXMgYWxsIHRoZSBzdGFja3MsXG4gICAqIHdlIGNhbiBpbnZva2UgaXQgb25jZSBhbmQgY2FjaGUgdGhlIHJlc3BvbnNlIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICAgKi9cbiAgcHVibGljIGFzc2VtYmx5PzogY3hhcGkuQ2xvdWRBc3NlbWJseTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBBcHBTdGFja3NQcm9wcykge31cblxuICAvKipcbiAgICogTGlzdCBhbGwgc3RhY2tzIGluIHRoZSBDWCBhbmQgcmV0dXJuIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAqXG4gICAqIEl0J3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIG5vIHN0YWNrcyB0byBzZWxlY3QsIG9yIGlmIG9uZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnNcbiAgICogcmVmZXJzIHRvIGEgbm9uZXhpc3RhbnQgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VsZWN0U3RhY2tzKHNlbGVjdG9yczogc3RyaW5nW10sIG9wdGlvbnM6IFNlbGVjdFN0YWNrc09wdGlvbnMpOiBQcm9taXNlPGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdPiB7XG4gICAgc2VsZWN0b3JzID0gc2VsZWN0b3JzLmZpbHRlcihzID0+IHMgIT0gbnVsbCk7IC8vIGZpbHRlciBudWxsL3VuZGVmaW5lZFxuXG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5saXN0U3RhY2tzKCk7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5kZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLkFsbFN0YWNrczpcbiAgICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uTm9uZTpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5Pbmx5U2luZ2xlOlxuICAgICAgICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbmNlIHRoaXMgYXBwIGluY2x1ZGVzIG1vcmUgdGhhbiBhIHNpbmdsZSBzdGFjaywgc3BlY2lmeSB3aGljaCBzdGFja3MgdG8gdXNlICh3aWxkY2FyZHMgYXJlIHN1cHBvcnRlZClcXG5gICtcbiAgICAgICAgICAgICAgYFN0YWNrczogJHtzdGFja3MubWFwKHggPT4geC5uYW1lKS5qb2luKCcgJyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkZWZhdWx0IGJlaGF2aW9yOiAke29wdGlvbnMuZGVmYXVsdEJlaGF2aW9yfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFsbFN0YWNrcyA9IG5ldyBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KCk7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGFsbFN0YWNrcy5zZXQoc3RhY2submFtZSwgc3RhY2spO1xuICAgIH1cblxuICAgIC8vIEZvciBldmVyeSBzZWxlY3RvciBhcmd1bWVudCwgcGljayBzdGFja3MgZnJvbSB0aGUgbGlzdC5cbiAgICBjb25zdCBzZWxlY3RlZFN0YWNrcyA9IG5ldyBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KCk7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHNlbGVjdG9ycykge1xuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGlmIChtaW5pbWF0Y2goc3RhY2submFtZSwgcGF0dGVybikgJiYgIXNlbGVjdGVkU3RhY2tzLmhhcyhzdGFjay5uYW1lKSkge1xuICAgICAgICAgIHNlbGVjdGVkU3RhY2tzLnNldChzdGFjay5uYW1lLCBzdGFjayk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBmb3VuZCBtYXRjaGluZyAnJHtwYXR0ZXJufScuIFVzZSBcImxpc3RcIiB0byBwcmludCBtYW5pZmVzdGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuZCA9IG9wdGlvbnMuZXh0ZW5kIHx8IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZTtcbiAgICBzd2l0Y2ggKGV4dGVuZCkge1xuICAgICAgY2FzZSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLkRvd25zdHJlYW06XG4gICAgICAgIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbTpcbiAgICAgICAgaW5jbHVkZVVwc3RyZWFtU3RhY2tzKHNlbGVjdGVkU3RhY2tzLCBhbGxTdGFja3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3JpZ2luYWwgYXJyYXkgYmVjYXVzZSBpdCBpcyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICBjb25zdCBzZWxlY3RlZExpc3QgPSBzdGFja3MuZmlsdGVyKHMgPT4gc2VsZWN0ZWRTdGFja3MuaGFzKHMubmFtZSkpO1xuXG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHN0YWNrcyBpbiB0aGUgQ1hcbiAgICpcbiAgICogSWYgdGhlIHN0YWNrcyBoYXZlIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHRoZW0sIHRoZXkgd2lsbCBiZSByZXR1cm5lZCBpblxuICAgKiB0b3BvbG9naWNhbGx5IHNvcnRlZCBvcmRlci4gSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBub3QgaW4gdGhlXG4gICAqIHNldCwgdGhleSB3aWxsIGJlIGlnbm9yZWQ7IGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdGhhdCB0aGVcbiAgICogbm9uLXNlbGVjdGVkIHN0YWNrcyBoYXZlIGFscmVhZHkgYmVlbiBkZXBsb3llZCBwcmV2aW91c2x5LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zeW50aGVzaXplU3RhY2tzKCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnN0YWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2luZ2xlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5zeW50aGVzaXplU3RhY2tzKCk7XG4gICAgY29uc3Qgc3RhY2sgPSByZXNwLmdldFN0YWNrKHN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoZXNpemUgYSBzZXQgb2Ygc3RhY2tzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZVN0YWNrcygpOiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+IHtcbiAgICBpZiAodGhpcy5hc3NlbWJseSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZW1ibHk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhY2tWZXJzaW9uczogYm9vbGVhbiA9IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd2ZXJzaW9uUmVwb3J0aW5nJ10pO1xuXG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gcnVuIHRoZSBjbG91ZCBleGVjdXRhYmxlIG11bHRpcGxlIHRpbWVzIGluIG9yZGVyIHRvIHNhdGlzZnkgYWxsIG1pc3NpbmcgY29udGV4dFxuICAgIGxldCBwcmV2aW91c2x5TWlzc2luZ0tleXM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMucHJvcHMuc3ludGhlc2l6ZXIodGhpcy5wcm9wcy5hd3MsIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGlmIChhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gbWlzc2luZ0NvbnRleHRLZXlzKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcpO1xuXG4gICAgICAgIGxldCB0cnlMb29rdXAgPSB0cnVlO1xuICAgICAgICBpZiAocHJldmlvdXNseU1pc3NpbmdLZXlzICYmIHNldHNFcXVhbChtaXNzaW5nS2V5cywgcHJldmlvdXNseU1pc3NpbmdLZXlzKSkge1xuICAgICAgICAgIGRlYnVnKGBOb3QgbWFraW5nIHByb2dyZXNzIHRyeWluZyB0byByZXNvbHZlIGVudmlyb25tZW50YWwgY29udGV4dC4gR2l2aW5nIHVwLmApO1xuICAgICAgICAgIHRyeUxvb2t1cCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNseU1pc3NpbmdLZXlzID0gbWlzc2luZ0tleXM7XG5cbiAgICAgICAgaWYgKHRyeUxvb2t1cCkge1xuICAgICAgICAgIGRlYnVnKGBTb21lIGNvbnRleHQgaW5mb3JtYXRpb24gaXMgbWlzc2luZy4gRmV0Y2hpbmcuLi5gKTtcblxuICAgICAgICAgIGF3YWl0IGNvbnRleHRwcm92aWRlcnMucHJvdmlkZUNvbnRleHRWYWx1ZXMoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZywgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLmNvbnRleHQsIHRoaXMucHJvcHMuYXdzKTtcblxuICAgICAgICAgIC8vIENhY2hlIHRoZSBuZXcgY29udGV4dCB0byBkaXNrXG4gICAgICAgICAgYXdhaXQgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNhdmVDb250ZXh0KCk7XG5cbiAgICAgICAgICAvLyBFeGVjdXRlIGFnYWluXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrVmVyc2lvbnMgJiYgYXNzZW1ibHkucnVudGltZSkge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gZm9ybWF0TW9kdWxlcyhhc3NlbWJseS5ydW50aW1lKTtcbiAgICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBhc3NlbWJseS5zdGFja3MpIHtcbiAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcykge1xuICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc291cmNlUHJlc2VudCA9IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbiA9PT0gY3hhcGkuVU5LTk9XTl9SRUdJT05cbiAgICAgICAgICAgIHx8IFJlZ2lvbkluZm8uZ2V0KHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbikuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZTtcbiAgICAgICAgICBpZiAocmVzb3VyY2VQcmVzZW50KSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YSkge1xuICAgICAgICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgVHlwZTogJ0FXUzo6Q0RLOjpNZXRhZGF0YScsXG4gICAgICAgICAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgTW9kdWxlczogbW9kdWxlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbiA9PT0gY3hhcGkuVU5LTk9XTl9SRUdJT04pIHtcbiAgICAgICAgICAgICAgICBzdGFjay50ZW1wbGF0ZS5Db25kaXRpb25zID0gc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kTmFtZSA9ICdDREtNZXRhZGF0YUF2YWlsYWJsZSc7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFjay50ZW1wbGF0ZS5Db25kaXRpb25zW2NvbmROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9uc1tjb25kTmFtZV0gPSBfbWFrZUNka01ldGFkYXRhQXZhaWxhYmxlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEuQ29uZGl0aW9uID0gY29uZE5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLm5hbWV9IGFscmVhZHkgaW5jbHVkZXMgYSAke2NvbmROYW1lfSBjb25kaXRpb25gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLm5hbWV9IGFscmVhZHkgaW5jbHVkZXMgYSBDREtNZXRhZGF0YSByZXNvdXJjZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGwgZ29vZCwgcmV0dXJuXG4gICAgICB0aGlzLmFzc2VtYmx5ID0gYXNzZW1ibHk7XG4gICAgICByZXR1cm4gYXNzZW1ibHk7XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE1vZHVsZXMocnVudGltZTogY3hhcGkuUnVudGltZUluZm8pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgICAgICAvLyBpbmplY3QgdG9vbGtpdCB2ZXJzaW9uIHRvIGxpc3Qgb2YgbW9kdWxlc1xuICAgICAgICBjb25zdCB0b29sa2l0VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgICAgIG1vZHVsZXMucHVzaChgYXdzLWNkaz0ke3Rvb2xraXRWZXJzaW9ufWApO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJ1bnRpbWUubGlicmFyaWVzKS5zb3J0KCkpIHtcbiAgICAgICAgICBtb2R1bGVzLnB1c2goYCR7a2V5fT0ke3J1bnRpbWUubGlicmFyaWVzW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZXMuam9pbignLCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0YWdzIGF2YWlsYWJsZSBpbiB0aGUgc3RhY2sgbWV0YWRhdGEuXG4gICAqL1xuICBwdWJsaWMgZ2V0VGFnc0Zyb21TdGFja01ldGFkYXRhKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBUYWdbXSB7XG4gICAgcmV0dXJuIGZsYXRNYXAoc3RhY2suZmluZE1ldGFkYXRhQnlUeXBlKGN4YXBpLlNUQUNLX1RBR1NfTUVUQURBVEFfS0VZKSwgeCA9PiB4LmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHB1YmxpYyBwcm9jZXNzTWV0YWRhdGEoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSkge1xuICAgIGxldCB3YXJuaW5ncyA9IGZhbHNlO1xuICAgIGxldCBlcnJvcnMgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2Ygc3RhY2subWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmxldmVsKSB7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuV0FSTklORzpcbiAgICAgICAgICAgIHdhcm5pbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKHdhcm5pbmcsICdXYXJuaW5nJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5FUlJPUjpcbiAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50TWVzc2FnZShlcnJvciwgJ0Vycm9yJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5JTkZPOlxuICAgICAgICAgICAgdGhpcy5wcmludE1lc3NhZ2UocHJpbnQsICdJbmZvJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgIXRoaXMucHJvcHMuaWdub3JlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLnN0cmljdCAmJiB3YXJuaW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB3YXJuaW5ncyAoLS1zdHJpY3QgbW9kZSknKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByaW50TWVzc2FnZShsb2dGbjogKHM6IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmcsIGlkOiBzdHJpbmcsIGVudHJ5OiBjeGFwaS5NZXRhZGF0YUVudHJ5KSB7XG4gICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHtpZH1dICR7ZW50cnkuZGF0YX1gKTtcblxuICAgIGlmICh0aGlzLnByb3BzLnZlcmJvc2UgJiYgZW50cnkudHJhY2UpIHtcbiAgICAgIGxvZ0ZuKGAgICR7ZW50cnkudHJhY2Uuam9pbignXFxuICAnKX1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaW5lIHRoZSBuYW1lcyBvZiBhIHNldCBvZiBzdGFja3MgdXNpbmcgYSBjb21tYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFN0YWNrTmFtZXMoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSk6IHN0cmluZyB7XG4gIHJldHVybiBzdGFja3MubWFwKHMgPT4gcy5uYW1lKS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIFdoZW4gc2VsZWN0aW5nIHN0YWNrcywgd2hhdCBvdGhlciBzdGFja3MgdG8gaW5jbHVkZSBiZWNhdXNlIG9mIGRlcGVuZGVuY2llc1xuICovXG5leHBvcnQgZW51bSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIERvbid0IHNlbGVjdCBhbnkgZXh0cmEgc3RhY2tzXG4gICAqL1xuICBOb25lLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoaXMgc3RhY2sgZGVwZW5kcyBvblxuICAgKi9cbiAgVXBzdHJlYW0sXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoaXMgc3RhY2tcbiAgICovXG4gIERvd25zdHJlYW1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IGRlcGVuZCBvbiB0aGUgc3RhY2tzIGFscmVhZHkgaW4gdGhlIHNldFxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKFxuICAgIHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+LFxuICAgIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgbGV0IG1hZGVQcm9ncmVzcyA9IHRydWU7XG4gIHdoaWxlIChtYWRlUHJvZ3Jlc3MpIHtcbiAgICBtYWRlUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHN0YWNrXSBvZiBhbGxTdGFja3MpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGlzIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBBTkQgaXQgZGVwZW5kcyBvbiBhIHN0YWNrIHRoYXQncyBpbiB0aGUgc2VsZWN0ZWQgc2V0XG4gICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhuYW1lKSAmJiAoc3RhY2suZGVwZW5kZW5jaWVzIHx8IFtdKS5zb21lKGRlcCA9PiBzZWxlY3RlZFN0YWNrcy5oYXMoZGVwLmlkKSkpIHtcbiAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KG5hbWUsIHN0YWNrKTtcbiAgICAgICAgYWRkZWQucHVzaChuYW1lKTtcbiAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kaW5nIHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoYXQgc3RhY2tzIGluIHRoZSBzZXQgZGVwZW5kIG9uXG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVVwc3RyZWFtU3RhY2tzKFxuICAgIHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+LFxuICAgIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lOYW1lIG9mIHN0YWNrLmRlcGVuZGVuY2llcy5tYXAoeCA9PiB4LmlkKSkge1xuICAgICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhkZXBlbmRlbmN5TmFtZSkgJiYgYWxsU3RhY2tzLmhhcyhkZXBlbmRlbmN5TmFtZSkpIHtcbiAgICAgICAgICBhZGRlZC5wdXNoKGRlcGVuZGVuY3lOYW1lKTtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoZGVwZW5kZW5jeU5hbWUsIGFsbFN0YWNrcy5nZXQoZGVwZW5kZW5jeU5hbWUpISk7XG4gICAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgcHJpbnQoJ0luY2x1ZGluZyBkZXBlbmRlbmN5IHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RlZFN0YWNrIGV4dGVuZHMgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBzdGFjayBiZWZvcmUgcmVuYW1pbmdcbiAgICovXG4gIG9yaWdpbmFsTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZyB7XG4gIHJlYWRvbmx5IEtleTogc3RyaW5nO1xuICByZWFkb25seSBWYWx1ZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybiBhbGwga2V5cyBvZiBtaXNpc25nIGNvbnRleHQgaXRlbXNcbiAqL1xuZnVuY3Rpb24gbWlzc2luZ0NvbnRleHRLZXlzKG1pc3Npbmc/OiBjeGFwaS5NaXNzaW5nQ29udGV4dFtdKTogU2V0PHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFNldCgobWlzc2luZyB8fCBbXSkubWFwKG0gPT4gbS5rZXkpKTtcbn1cblxuZnVuY3Rpb24gc2V0c0VxdWFsPEE+KGE6IFNldDxBPiwgYjogU2V0PEE+KSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgZm9yIChjb25zdCB4IG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKHgpKSB7IHJldHVybiBmYWxzZTsgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfbWFrZUNka01ldGFkYXRhQXZhaWxhYmxlQ29uZGl0aW9uKCkge1xuICByZXR1cm4gX2ZuT3IoUmVnaW9uSW5mby5yZWdpb25zXG4gICAgLmZpbHRlcihyaSA9PiByaS5jZGtNZXRhZGF0YVJlc291cmNlQXZhaWxhYmxlKVxuICAgIC5tYXAocmkgPT4gKHsgJ0ZuOjpFcXVhbHMnOiBbeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgcmkubmFtZV0gfSkpKTtcbn1cblxuLyoqXG4gKiBUaGlzIHRha2VzIGEgYnVuY2ggb2Ygb3BlcmFuZHMgYW5kIGNyYWZ0cyBhbiBgRm46Ok9yYCBmb3IgdGhvc2UuIEZ1bm55IHRoaW5nIGlzIGBGbjo6T3JgIHJlcXVpcmVzXG4gKiBhdCBsZWFzdCAyIG9wZXJhbmRzIGFuZCBhdCBtb3N0IDEwIG9wZXJhbmRzLCBzbyB3ZSBoYXZlIHRvLi4uIGRvIHRoaXMuXG4gKi9cbmZ1bmN0aW9uIF9mbk9yKG9wZXJhbmRzOiBhbnlbXSk6IGFueSB7XG4gIGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBidWlsZCBgRm46Ok9yYCB3aXRoIHplcm8gb3BlcmFuZHMhJyk7XG4gIH1cbiAgaWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvcGVyYW5kc1swXTtcbiAgfVxuICBpZiAob3BlcmFuZHMubGVuZ3RoIDw9IDEwKSB7XG4gICAgcmV0dXJuIHsgJ0ZuOjpPcic6IG9wZXJhbmRzIH07XG4gIH1cbiAgcmV0dXJuIF9mbk9yKF9pbkdyb3Vwc09mKG9wZXJhbmRzLCAxMCkubWFwKGdyb3VwID0+IF9mbk9yKGdyb3VwKSkpO1xufVxuXG5mdW5jdGlvbiBfaW5Hcm91cHNPZjxUPihhcnJheTogVFtdLCBtYXhHcm91cDogbnVtYmVyKTogVFtdW10ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8VFtdPigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBtYXhHcm91cCkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGksIGkgKyBtYXhHcm91cCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=