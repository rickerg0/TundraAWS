#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const colors = require("colors/safe");
const path = require("path");
const yargs = require("yargs");
const lib_1 = require("../lib");
const environments_1 = require("../lib/api/cxapp/environments");
const exec_1 = require("../lib/api/cxapp/exec");
const stacks_1 = require("../lib/api/cxapp/stacks");
const deployment_target_1 = require("../lib/api/deployment-target");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
const diff_1 = require("../lib/diff");
const init_1 = require("../lib/init");
const logging_1 = require("../lib/logging");
const plugin_1 = require("../lib/plugin");
const serialize_1 = require("../lib/serialize");
const settings_1 = require("../lib/settings");
const version = require("../lib/version");
// tslint:disable:no-shadowed-variable max-line-length
async function parseCommandLineArguments() {
    const initTemplateLanuages = await init_1.availableInitLanguages;
    return yargs
        .env('CDK')
        .usage('Usage: cdk -a <cdk-app> COMMAND')
        .option('app', { type: 'string', alias: 'a', desc: 'REQUIRED: command-line for executing your app or a cloud assembly directory (e.g. "node bin/my-app.js")', requiresArg: true })
        .option('context', { type: 'array', alias: 'c', desc: 'Add contextual string parameter (KEY=VALUE)', nargs: 1, requiresArg: true })
        .option('plugin', { type: 'array', alias: 'p', desc: 'Name or path of a node package that extend the CDK features. Can be specified multiple times', nargs: 1 })
        .option('trace', { type: 'boolean', desc: 'Print trace for stack warnings' })
        .option('strict', { type: 'boolean', desc: 'Do not construct stacks with warnings' })
        .option('ignore-errors', { type: 'boolean', default: false, desc: 'Ignores synthesis errors, which will likely produce an invalid output' })
        .option('json', { type: 'boolean', alias: 'j', desc: 'Use JSON output instead of YAML when templates are printed to STDOUT', default: false })
        .option('verbose', { type: 'boolean', alias: 'v', desc: 'Show debug logs', default: false })
        .option('profile', { type: 'string', desc: 'Use the indicated AWS profile as the default environment', requiresArg: true })
        .option('proxy', { type: 'string', desc: 'Use the indicated proxy. Will read from HTTPS_PROXY environment variable if not specified.', requiresArg: true })
        .option('ec2creds', { type: 'boolean', alias: 'i', default: undefined, desc: 'Force trying to fetch EC2 instance credentials. Default: guess EC2 instance status.' })
        .option('version-reporting', { type: 'boolean', desc: 'Include the "AWS::CDK::Metadata" resource in synthesized templates (enabled by default)', default: undefined })
        .option('path-metadata', { type: 'boolean', desc: 'Include "aws:cdk:path" CloudFormation metadata for each resource (enabled by default)', default: true })
        .option('asset-metadata', { type: 'boolean', desc: 'Include "aws:asset:*" CloudFormation metadata for resources that user assets (enabled by default)', default: true })
        .option('role-arn', { type: 'string', alias: 'r', desc: 'ARN of Role to use when invoking CloudFormation', default: undefined, requiresArg: true })
        .option('toolkit-stack-name', { type: 'string', desc: 'The name of the CDK toolkit stack', requiresArg: true })
        .option('staging', { type: 'boolean', desc: 'Copy assets to the output directory (use --no-staging to disable, needed for local debugging the source files with SAM CLI)', default: true })
        .option('output', { type: 'string', alias: 'o', desc: 'Emits the synthesized cloud assembly into a directory (default: cdk.out)', requiresArg: true })
        .option('no-color', { type: 'boolean', desc: 'Removes colors and other style from console output', default: false })
        .command(['list [STACKS..]', 'ls [STACKS..]'], 'Lists all stacks in the app', yargs => yargs
        .option('long', { type: 'boolean', default: false, alias: 'l', desc: 'Display environment information for each stack' }))
        .command(['synthesize [STACKS..]', 'synth [STACKS..]'], 'Synthesizes and prints the CloudFormation template for this stack', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' }))
        .command('bootstrap [ENVIRONMENTS..]', 'Deploys the CDK toolkit stack into an AWS environment', yargs => yargs
        .option('bootstrap-bucket-name', { type: 'string', alias: ['b', 'toolkit-bucket-name'], desc: 'The name of the CDK toolkit bucket', default: undefined })
        .option('bootstrap-kms-key-id', { type: 'string', desc: 'AWS KMS master key ID used for the SSE-KMS encryption', default: undefined })
        .option('tags', { type: 'array', alias: 't', desc: 'Tags to add for the stack (KEY=VALUE)', nargs: 1, requiresArg: true, default: [] }))
        .command('deploy [STACKS..]', 'Deploys the stack(s) named STACKS into your AWS account', yargs => yargs
        .option('build-exclude', { type: 'array', alias: 'E', nargs: 1, desc: 'Do not rebuild asset with the given ID. Can be specified multiple times.', default: [] })
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' })
        .option('require-approval', { type: 'string', choices: [diff_1.RequireApproval.Never, diff_1.RequireApproval.AnyChange, diff_1.RequireApproval.Broadening], desc: 'What security-sensitive changes need manual approval' })
        .option('ci', { type: 'boolean', desc: 'Force CI detection. Use --no-ci to disable CI autodetection.', default: process.env.CI !== undefined })
        .option('notification-arns', { type: 'array', desc: 'ARNs of SNS topics that CloudFormation will notify with stack related events', nargs: 1, requiresArg: true })
        .option('tags', { type: 'array', alias: 't', desc: 'Tags to add to the stack (KEY=VALUE)', nargs: 1, requiresArg: true }))
        .command('destroy [STACKS..]', 'Destroy the stack(s) named STACKS', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependees' })
        .option('force', { type: 'boolean', alias: 'f', desc: 'Do not ask for confirmation before destroying the stacks' }))
        .command('diff [STACKS..]', 'Compares the specified stack with the deployed stack or a local template file, and returns with status 1 if any difference is found', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only diff requested stacks, don\'t include dependencies' })
        .option('context-lines', { type: 'number', desc: 'Number of context lines to include in arbitrary JSON diff rendering', default: 3, requiresArg: true })
        .option('template', { type: 'string', desc: 'The path to the CloudFormation template to compare with', requiresArg: true })
        .option('strict', { type: 'boolean', desc: 'Do not filter out AWS::CDK::Metadata resources', default: false }))
        .command('metadata [STACK]', 'Returns all metadata associated with this stack')
        .command('init [TEMPLATE]', 'Create a new, empty CDK project from a template. Invoked without TEMPLATE, the app template will be used.', yargs => yargs
        .option('language', { type: 'string', alias: 'l', desc: 'The language to be used for the new project (default can be configured in ~/.cdk.json)', choices: initTemplateLanuages })
        .option('list', { type: 'boolean', desc: 'List the available templates' }))
        .commandDir('../lib/commands', { exclude: /^_.*/ })
        .version(version.DISPLAY_VERSION)
        .demandCommand(1, '') // just print help
        .help()
        .alias('h', 'help')
        .epilogue([
        'If your app has a single stack, there is no need to specify the stack name',
        'If one of cdk.json or ~/.cdk.json exists, options specified there will be used as defaults. Settings in cdk.json take precedence.'
    ].join('\n\n'))
        .argv;
}
if (!process.stdout.isTTY) {
    colors.disable();
}
async function initCommandLine() {
    const argv = await parseCommandLineArguments();
    if (argv.verbose) {
        logging_1.setVerbose();
    }
    logging_1.debug('CDK toolkit version:', version.DISPLAY_VERSION);
    logging_1.debug('Command line arguments:', argv);
    const aws = new lib_1.SDK({
        profile: argv.profile,
        proxyAddress: argv.proxy,
        ec2creds: argv.ec2creds,
    });
    const configuration = new settings_1.Configuration(argv);
    await configuration.load();
    const provisioner = new deployment_target_1.CloudFormationDeploymentTarget({ aws });
    const appStacks = new stacks_1.AppStacks({
        verbose: argv.trace || argv.verbose,
        ignoreErrors: argv['ignore-errors'],
        strict: argv.strict,
        configuration,
        aws,
        synthesizer: exec_1.execProgram,
    });
    /** Function to load plug-ins, using configurations additively. */
    function loadPlugins(...settings) {
        const loaded = new Set();
        for (const source of settings) {
            const plugins = source.get(['plugin']) || [];
            for (const plugin of plugins) {
                const resolved = tryResolve(plugin);
                if (loaded.has(resolved)) {
                    continue;
                }
                logging_1.debug(`Loading plug-in: ${colors.green(plugin)} from ${colors.blue(resolved)}`);
                plugin_1.PluginHost.instance.load(plugin);
                loaded.add(resolved);
            }
        }
        function tryResolve(plugin) {
            try {
                return require.resolve(plugin);
            }
            catch (e) {
                logging_1.error(`Unable to resolve plugin ${colors.green(plugin)}: ${e.stack}`);
                throw new Error(`Unable to resolve plug-in: ${plugin}`);
            }
        }
    }
    loadPlugins(configuration.settings);
    const cmd = argv._[0];
    // Bundle up global objects so the commands have access to them
    const commandOptions = { args: argv, appStacks, configuration, aws };
    try {
        const returnValue = argv.commandHandler
            ? await argv.commandHandler(commandOptions)
            : await main(cmd, argv);
        if (typeof returnValue === 'object') {
            return toJsonOrYaml(returnValue);
        }
        else if (typeof returnValue === 'string') {
            return returnValue;
        }
        else {
            return returnValue;
        }
    }
    finally {
        await version.displayVersionMessage();
    }
    async function main(command, args) {
        const toolkitStackName = configuration.settings.get(['toolkitStackName']) || deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME;
        if (toolkitStackName !== deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME) {
            logging_1.print(`Toolkit stack: ${colors.bold(toolkitStackName)}`);
        }
        args.STACKS = args.STACKS || [];
        args.ENVIRONMENTS = args.ENVIRONMENTS || [];
        const cli = new cdk_toolkit_1.CdkToolkit({ appStacks, provisioner });
        switch (command) {
            case 'ls':
            case 'list':
                return await cliList(args.STACKS, { long: args.long });
            case 'diff':
                return await cli.diff({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    templatePath: args.template,
                    strict: args.strict,
                    contextLines: args.contextLines
                });
            case 'bootstrap':
                return await cliBootstrap(args.ENVIRONMENTS, toolkitStackName, args.roleArn, {
                    bucketName: configuration.settings.get(['toolkitBucket', 'bucketName']),
                    kmsKeyId: configuration.settings.get(['toolkitBucket', 'kmsKeyId']),
                    tags: configuration.settings.get(['tags'])
                });
            case 'deploy':
                return await cli.deploy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    toolkitStackName,
                    roleArn: args.roleArn,
                    notificationArns: args.notificationArns,
                    requireApproval: configuration.settings.get(['requireApproval']),
                    ci: args.ci,
                    reuseAssets: args['build-exclude'],
                    tags: configuration.settings.get(['tags']),
                    sdk: aws,
                });
            case 'destroy':
                return await cli.destroy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    force: args.force,
                    roleArn: args.roleArn,
                    sdk: aws,
                });
            case 'synthesize':
            case 'synth':
                return await cliSynthesize(args.STACKS, args.exclusively);
            case 'metadata':
                return await cliMetadata(await findStack(args.STACK));
            case 'init':
                const language = configuration.settings.get(['language']);
                if (args.list) {
                    return await init_1.printAvailableTemplates(language);
                }
                else {
                    return await init_1.cliInit(args.TEMPLATE, language);
                }
            default:
                throw new Error('Unknown command: ' + command);
        }
    }
    async function cliMetadata(stackName) {
        const s = await appStacks.synthesizeStack(stackName);
        return s.manifest.metadata || {};
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param environmentGlobs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided,
     *             all stacks are implicitly selected.
     * @param toolkitStackName the name to be used for the CDK Toolkit stack.
     */
    async function cliBootstrap(environmentGlobs, toolkitStackName, roleArn, props) {
        // Two modes of operation.
        //
        // If there is an '--app' argument, we select the environments from the app. Otherwise we just take the user
        // at their word that they know the name of the environment.
        const app = configuration.settings.get(['app']);
        const environments = app ? await environments_1.globEnvironmentsFromStacks(appStacks, environmentGlobs, aws) : environments_1.environmentsFromDescriptors(environmentGlobs);
        await Promise.all(environments.map(async (environment) => {
            logging_1.success(' ⏳  Bootstrapping environment %s...', colors.blue(environment.name));
            try {
                const result = await lib_1.bootstrapEnvironment(environment, aws, toolkitStackName, roleArn, props);
                const message = result.noOp ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                logging_1.success(message, colors.blue(environment.name));
            }
            catch (e) {
                logging_1.error(' ❌  Environment %s failed bootstrapping: %s', colors.blue(environment.name), e);
                throw e;
            }
        }));
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implictly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async function cliSynthesize(stackNames, exclusively) {
        // Only autoselect dependencies if it doesn't interfere with user request or output options
        const autoSelectDependencies = !exclusively;
        const stacks = await appStacks.selectStacks(stackNames, {
            extend: autoSelectDependencies ? stacks_1.ExtendedStackSelection.Upstream : stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.AllStacks
        });
        appStacks.processMetadata(stacks);
        // if we have a single stack, print it to STDOUT
        if (stacks.length === 1) {
            return stacks[0].template;
        }
        // This is a slight hack; in integ mode we allow multiple stacks to be synthesized to stdout sequentially.
        // This is to make it so that we can support multi-stack integ test expectations, without so drastically
        // having to change the synthesis format that we have to rerun all integ tests.
        //
        // Because this feature is not useful to consumers (the output is missing
        // the stack names), it's not exposed as a CLI flag. Instead, it's hidden
        // behind an environment variable.
        const isIntegMode = process.env.CDK_INTEG_MODE === '1';
        if (isIntegMode) {
            return stacks.map(s => s.template);
        }
        // not outputting template to stdout, let's explain things to the user a little bit...
        logging_1.success(`Successfully synthesized to ${colors.blue(path.resolve(appStacks.assembly.directory))}`);
        logging_1.print(`Supply a stack name (${stacks.map(s => colors.green(s.name)).join(', ')}) to display its template.`);
        return undefined;
    }
    async function cliList(selectors, options = {}) {
        const stacks = await appStacks.selectStacks(selectors, { defaultBehavior: stacks_1.DefaultSelection.AllStacks });
        // if we are in "long" mode, emit the array as-is (JSON/YAML)
        if (options.long) {
            const long = [];
            for (const stack of stacks) {
                long.push({
                    name: stack.name,
                    environment: stack.environment
                });
            }
            return long; // will be YAML formatted output
        }
        // just print stack names
        for (const stack of stacks) {
            logging_1.data(stack.name);
        }
        return 0; // exit-code
    }
    /**
     * Match a single stack from the list of available stacks
     */
    async function findStack(name) {
        const stacks = await appStacks.selectStacks([name], {
            extend: stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.None
        });
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.length > 1) {
            throw new Error(`This command requires exactly one stack and we matched more than one: ${stacks.map(x => x.name)}`);
        }
        return stacks[0].name;
    }
    function toJsonOrYaml(object) {
        return serialize_1.serializeStructure(object, argv.json);
    }
}
initCommandLine()
    .then(value => {
    if (value == null) {
        return;
    }
    if (typeof value === 'string') {
        logging_1.data(value);
    }
    else if (typeof value === 'number') {
        process.exit(value);
    }
})
    .catch(err => {
    logging_1.error(err.message);
    logging_1.debug(err.stack);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHVDQUFxQztBQUVyQyxzQ0FBdUM7QUFDdkMsNkJBQThCO0FBQzlCLCtCQUFnQztBQUVoQyxnQ0FBOEU7QUFDOUUsZ0VBQXdHO0FBQ3hHLGdEQUFvRDtBQUNwRCxvREFBOEY7QUFDOUYsb0VBQTBHO0FBQzFHLG9EQUFnRDtBQUNoRCxzQ0FBOEM7QUFDOUMsc0NBQXVGO0FBQ3ZGLDRDQUFnRjtBQUNoRiwwQ0FBMkM7QUFDM0MsZ0RBQXNEO0FBQ3RELDhDQUEwRDtBQUMxRCwwQ0FBMkM7QUFFM0Msc0RBQXNEO0FBQ3RELEtBQUssVUFBVSx5QkFBeUI7SUFDdEMsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLDZCQUFzQixDQUFDO0lBQzFELE9BQU8sS0FBSztTQUNULEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDVixLQUFLLENBQUMsaUNBQWlDLENBQUM7U0FDeEMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUseUdBQXlHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2pMLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDZDQUE2QyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2xJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDhGQUE4RixFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUMvSixNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsZ0NBQWdDLEVB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QUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDWCxlQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLGVBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5vZGVcbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB5YXJncyA9IHJlcXVpcmUoJ3lhcmdzJyk7XG5cbmltcG9ydCB7IGJvb3RzdHJhcEVudmlyb25tZW50LCBCb290c3RyYXBFbnZpcm9ubWVudFByb3BzLCBTREsgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgZW52aXJvbm1lbnRzRnJvbURlc2NyaXB0b3JzLCBnbG9iRW52aXJvbm1lbnRzRnJvbVN0YWNrcyB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvZW52aXJvbm1lbnRzJztcbmltcG9ydCB7IGV4ZWNQcm9ncmFtIH0gZnJvbSAnLi4vbGliL2FwaS9jeGFwcC9leGVjJztcbmltcG9ydCB7IEFwcFN0YWNrcywgRGVmYXVsdFNlbGVjdGlvbiwgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvc3RhY2tzJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uRGVwbG95bWVudFRhcmdldCwgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgfSBmcm9tICcuLi9saWIvYXBpL2RlcGxveW1lbnQtdGFyZ2V0JztcbmltcG9ydCB7IENka1Rvb2xraXQgfSBmcm9tICcuLi9saWIvY2RrLXRvb2xraXQnO1xuaW1wb3J0IHsgUmVxdWlyZUFwcHJvdmFsIH0gZnJvbSAnLi4vbGliL2RpZmYnO1xuaW1wb3J0IHsgYXZhaWxhYmxlSW5pdExhbmd1YWdlcywgY2xpSW5pdCwgcHJpbnRBdmFpbGFibGVUZW1wbGF0ZXMgfSBmcm9tICcuLi9saWIvaW5pdCc7XG5pbXBvcnQgeyBkYXRhLCBkZWJ1ZywgZXJyb3IsIHByaW50LCBzZXRWZXJib3NlLCBzdWNjZXNzIH0gZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgUGx1Z2luSG9zdCB9IGZyb20gJy4uL2xpYi9wbHVnaW4nO1xuaW1wb3J0IHsgc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vbGliL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uLCBTZXR0aW5ncyB9IGZyb20gJy4uL2xpYi9zZXR0aW5ncyc7XG5pbXBvcnQgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL2xpYi92ZXJzaW9uJyk7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLXNoYWRvd2VkLXZhcmlhYmxlIG1heC1saW5lLWxlbmd0aFxuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21tYW5kTGluZUFyZ3VtZW50cygpIHtcbiAgY29uc3QgaW5pdFRlbXBsYXRlTGFudWFnZXMgPSBhd2FpdCBhdmFpbGFibGVJbml0TGFuZ3VhZ2VzO1xuICByZXR1cm4geWFyZ3NcbiAgICAuZW52KCdDREsnKVxuICAgIC51c2FnZSgnVXNhZ2U6IGNkayAtYSA8Y2RrLWFwcD4gQ09NTUFORCcpXG4gICAgLm9wdGlvbignYXBwJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdhJywgZGVzYzogJ1JFUVVJUkVEOiBjb21tYW5kLWxpbmUgZm9yIGV4ZWN1dGluZyB5b3VyIGFwcCBvciBhIGNsb3VkIGFzc2VtYmx5IGRpcmVjdG9yeSAoZS5nLiBcIm5vZGUgYmluL215LWFwcC5qc1wiKScsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgLm9wdGlvbignY29udGV4dCcsIHsgdHlwZTogJ2FycmF5JywgYWxpYXM6ICdjJywgZGVzYzogJ0FkZCBjb250ZXh0dWFsIHN0cmluZyBwYXJhbWV0ZXIgKEtFWT1WQUxVRSknLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdwbHVnaW4nLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAncCcsIGRlc2M6ICdOYW1lIG9yIHBhdGggb2YgYSBub2RlIHBhY2thZ2UgdGhhdCBleHRlbmQgdGhlIENESyBmZWF0dXJlcy4gQ2FuIGJlIHNwZWNpZmllZCBtdWx0aXBsZSB0aW1lcycsIG5hcmdzOiAxIH0pXG4gICAgLm9wdGlvbigndHJhY2UnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ1ByaW50IHRyYWNlIGZvciBzdGFjayB3YXJuaW5ncycgfSlcbiAgICAub3B0aW9uKCdzdHJpY3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0RvIG5vdCBjb25zdHJ1Y3Qgc3RhY2tzIHdpdGggd2FybmluZ3MnIH0pXG4gICAgLm9wdGlvbignaWdub3JlLWVycm9ycycsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSwgZGVzYzogJ0lnbm9yZXMgc3ludGhlc2lzIGVycm9ycywgd2hpY2ggd2lsbCBsaWtlbHkgcHJvZHVjZSBhbiBpbnZhbGlkIG91dHB1dCcgfSlcbiAgICAub3B0aW9uKCdqc29uJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnaicsIGRlc2M6ICdVc2UgSlNPTiBvdXRwdXQgaW5zdGVhZCBvZiBZQU1MIHdoZW4gdGVtcGxhdGVzIGFyZSBwcmludGVkIHRvIFNURE9VVCcsIGRlZmF1bHQ6IGZhbHNlIH0pXG4gICAgLm9wdGlvbigndmVyYm9zZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ3YnLCBkZXNjOiAnU2hvdyBkZWJ1ZyBsb2dzJywgZGVmYXVsdDogZmFsc2UgfSlcbiAgICAub3B0aW9uKCdwcm9maWxlJywgeyB0eXBlOiAnc3RyaW5nJywgZGVzYzogJ1VzZSB0aGUgaW5kaWNhdGVkIEFXUyBwcm9maWxlIGFzIHRoZSBkZWZhdWx0IGVudmlyb25tZW50JywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdwcm94eScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdVc2UgdGhlIGluZGljYXRlZCBwcm94eS4gV2lsbCByZWFkIGZyb20gSFRUUFNfUFJPWFkgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgbm90IHNwZWNpZmllZC4nLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ2VjMmNyZWRzJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnaScsIGRlZmF1bHQ6IHVuZGVmaW5lZCwgZGVzYzogJ0ZvcmNlIHRyeWluZyB0byBmZXRjaCBFQzIgaW5zdGFuY2UgY3JlZGVudGlhbHMuIERlZmF1bHQ6IGd1ZXNzIEVDMiBpbnN0YW5jZSBzdGF0dXMuJyB9KVxuICAgIC5vcHRpb24oJ3ZlcnNpb24tcmVwb3J0aW5nJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdJbmNsdWRlIHRoZSBcIkFXUzo6Q0RLOjpNZXRhZGF0YVwiIHJlc291cmNlIGluIHN5bnRoZXNpemVkIHRlbXBsYXRlcyAoZW5hYmxlZCBieSBkZWZhdWx0KScsIGRlZmF1bHQ6IHVuZGVmaW5lZCB9KVxuICAgIC5vcHRpb24oJ3BhdGgtbWV0YWRhdGEnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0luY2x1ZGUgXCJhd3M6Y2RrOnBhdGhcIiBDbG91ZEZvcm1hdGlvbiBtZXRhZGF0YSBmb3IgZWFjaCByZXNvdXJjZSAoZW5hYmxlZCBieSBkZWZhdWx0KScsIGRlZmF1bHQ6IHRydWUgfSlcbiAgICAub3B0aW9uKCdhc3NldC1tZXRhZGF0YScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnSW5jbHVkZSBcImF3czphc3NldDoqXCIgQ2xvdWRGb3JtYXRpb24gbWV0YWRhdGEgZm9yIHJlc291cmNlcyB0aGF0IHVzZXIgYXNzZXRzIChlbmFibGVkIGJ5IGRlZmF1bHQpJywgZGVmYXVsdDogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3JvbGUtYXJuJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdyJywgZGVzYzogJ0FSTiBvZiBSb2xlIHRvIHVzZSB3aGVuIGludm9raW5nIENsb3VkRm9ybWF0aW9uJywgZGVmYXVsdDogdW5kZWZpbmVkLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3Rvb2xraXQtc3RhY2stbmFtZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdUaGUgbmFtZSBvZiB0aGUgQ0RLIHRvb2xraXQgc3RhY2snLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3N0YWdpbmcnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0NvcHkgYXNzZXRzIHRvIHRoZSBvdXRwdXQgZGlyZWN0b3J5ICh1c2UgLS1uby1zdGFnaW5nIHRvIGRpc2FibGUsIG5lZWRlZCBmb3IgbG9jYWwgZGVidWdnaW5nIHRoZSBzb3VyY2UgZmlsZXMgd2l0aCBTQU0gQ0xJKScsIGRlZmF1bHQ6IHRydWUgfSlcbiAgICAub3B0aW9uKCdvdXRwdXQnLCB7IHR5cGU6ICdzdHJpbmcnLCBhbGlhczogJ28nLCBkZXNjOiAnRW1pdHMgdGhlIHN5bnRoZXNpemVkIGNsb3VkIGFzc2VtYmx5IGludG8gYSBkaXJlY3RvcnkgKGRlZmF1bHQ6IGNkay5vdXQpJywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCduby1jb2xvcicsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnUmVtb3ZlcyBjb2xvcnMgYW5kIG90aGVyIHN0eWxlIGZyb20gY29uc29sZSBvdXRwdXQnLCBkZWZhdWx0OiBmYWxzZSB9KVxuICAgIC5jb21tYW5kKFsgJ2xpc3QgW1NUQUNLUy4uXScsICdscyBbU1RBQ0tTLi5dJyBdLCAnTGlzdHMgYWxsIHN0YWNrcyBpbiB0aGUgYXBwJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2xvbmcnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UsIGFsaWFzOiAnbCcsIGRlc2M6ICdEaXNwbGF5IGVudmlyb25tZW50IGluZm9ybWF0aW9uIGZvciBlYWNoIHN0YWNrJyB9KSlcbiAgICAuY29tbWFuZChbICdzeW50aGVzaXplIFtTVEFDS1MuLl0nLCAnc3ludGggW1NUQUNLUy4uXScgXSwgJ1N5bnRoZXNpemVzIGFuZCBwcmludHMgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvciB0aGlzIHN0YWNrJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2V4Y2x1c2l2ZWx5JywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnZScsIGRlc2M6ICdPbmx5IGRlcGxveSByZXF1ZXN0ZWQgc3RhY2tzLCBkb25cXCd0IGluY2x1ZGUgZGVwZW5kZW5jaWVzJyB9KSlcbiAgICAuY29tbWFuZCgnYm9vdHN0cmFwIFtFTlZJUk9OTUVOVFMuLl0nLCAnRGVwbG95cyB0aGUgQ0RLIHRvb2xraXQgc3RhY2sgaW50byBhbiBBV1MgZW52aXJvbm1lbnQnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignYm9vdHN0cmFwLWJ1Y2tldC1uYW1lJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6IFsnYicsICd0b29sa2l0LWJ1Y2tldC1uYW1lJ10sIGRlc2M6ICdUaGUgbmFtZSBvZiB0aGUgQ0RLIHRvb2xraXQgYnVja2V0JywgZGVmYXVsdDogdW5kZWZpbmVkIH0pXG4gICAgICAub3B0aW9uKCdib290c3RyYXAta21zLWtleS1pZCcsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdBV1MgS01TIG1hc3RlciBrZXkgSUQgdXNlZCBmb3IgdGhlIFNTRS1LTVMgZW5jcnlwdGlvbicsIGRlZmF1bHQ6IHVuZGVmaW5lZCB9KVxuICAgICAgLm9wdGlvbigndGFncycsIHsgdHlwZTogJ2FycmF5JywgYWxpYXM6ICd0JywgZGVzYzogJ1RhZ3MgdG8gYWRkIGZvciB0aGUgc3RhY2sgKEtFWT1WQUxVRSknLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWUsIGRlZmF1bHQ6IFtdIH0pKVxuICAgIC5jb21tYW5kKCdkZXBsb3kgW1NUQUNLUy4uXScsICdEZXBsb3lzIHRoZSBzdGFjayhzKSBuYW1lZCBTVEFDS1MgaW50byB5b3VyIEFXUyBhY2NvdW50JywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2J1aWxkLWV4Y2x1ZGUnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAnRScsIG5hcmdzOiAxLCBkZXNjOiAnRG8gbm90IHJlYnVpbGQgYXNzZXQgd2l0aCB0aGUgZ2l2ZW4gSUQuIENhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMuJywgZGVmYXVsdDogW10gfSlcbiAgICAgIC5vcHRpb24oJ2V4Y2x1c2l2ZWx5JywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnZScsIGRlc2M6ICdPbmx5IGRlcGxveSByZXF1ZXN0ZWQgc3RhY2tzLCBkb25cXCd0IGluY2x1ZGUgZGVwZW5kZW5jaWVzJyB9KVxuICAgICAgLm9wdGlvbigncmVxdWlyZS1hcHByb3ZhbCcsIHsgdHlwZTogJ3N0cmluZycsIGNob2ljZXM6IFtSZXF1aXJlQXBwcm92YWwuTmV2ZXIsIFJlcXVpcmVBcHByb3ZhbC5BbnlDaGFuZ2UsIFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nXSwgZGVzYzogJ1doYXQgc2VjdXJpdHktc2Vuc2l0aXZlIGNoYW5nZXMgbmVlZCBtYW51YWwgYXBwcm92YWwnIH0pXG4gICAgICAub3B0aW9uKCdjaScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnRm9yY2UgQ0kgZGV0ZWN0aW9uLiBVc2UgLS1uby1jaSB0byBkaXNhYmxlIENJIGF1dG9kZXRlY3Rpb24uJywgZGVmYXVsdDogcHJvY2Vzcy5lbnYuQ0kgIT09IHVuZGVmaW5lZCB9KVxuICAgICAgLm9wdGlvbignbm90aWZpY2F0aW9uLWFybnMnLCB7dHlwZTogJ2FycmF5JywgZGVzYzogJ0FSTnMgb2YgU05TIHRvcGljcyB0aGF0IENsb3VkRm9ybWF0aW9uIHdpbGwgbm90aWZ5IHdpdGggc3RhY2sgcmVsYXRlZCBldmVudHMnLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWV9KVxuICAgICAgLm9wdGlvbigndGFncycsIHsgdHlwZTogJ2FycmF5JywgYWxpYXM6ICd0JywgZGVzYzogJ1RhZ3MgdG8gYWRkIHRvIHRoZSBzdGFjayAoS0VZPVZBTFVFKScsIG5hcmdzOiAxLCByZXF1aXJlc0FyZzogdHJ1ZSB9KSlcbiAgICAuY29tbWFuZCgnZGVzdHJveSBbU1RBQ0tTLi5dJywgJ0Rlc3Ryb3kgdGhlIHN0YWNrKHMpIG5hbWVkIFNUQUNLUycsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdleGNsdXNpdmVseScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2UnLCBkZXNjOiAnT25seSBkZXBsb3kgcmVxdWVzdGVkIHN0YWNrcywgZG9uXFwndCBpbmNsdWRlIGRlcGVuZGVlcycgfSlcbiAgICAgIC5vcHRpb24oJ2ZvcmNlJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnZicsIGRlc2M6ICdEbyBub3QgYXNrIGZvciBjb25maXJtYXRpb24gYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIHN0YWNrcycgfSkpXG4gICAgLmNvbW1hbmQoJ2RpZmYgW1NUQUNLUy4uXScsICdDb21wYXJlcyB0aGUgc3BlY2lmaWVkIHN0YWNrIHdpdGggdGhlIGRlcGxveWVkIHN0YWNrIG9yIGEgbG9jYWwgdGVtcGxhdGUgZmlsZSwgYW5kIHJldHVybnMgd2l0aCBzdGF0dXMgMSBpZiBhbnkgZGlmZmVyZW5jZSBpcyBmb3VuZCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdleGNsdXNpdmVseScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2UnLCBkZXNjOiAnT25seSBkaWZmIHJlcXVlc3RlZCBzdGFja3MsIGRvblxcJ3QgaW5jbHVkZSBkZXBlbmRlbmNpZXMnIH0pXG4gICAgICAub3B0aW9uKCdjb250ZXh0LWxpbmVzJywgeyB0eXBlOiAnbnVtYmVyJywgZGVzYzogJ051bWJlciBvZiBjb250ZXh0IGxpbmVzIHRvIGluY2x1ZGUgaW4gYXJiaXRyYXJ5IEpTT04gZGlmZiByZW5kZXJpbmcnLCBkZWZhdWx0OiAzLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgICAgLm9wdGlvbigndGVtcGxhdGUnLCB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjOiAnVGhlIHBhdGggdG8gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIHRvIGNvbXBhcmUgd2l0aCcsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgICAub3B0aW9uKCdzdHJpY3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0RvIG5vdCBmaWx0ZXIgb3V0IEFXUzo6Q0RLOjpNZXRhZGF0YSByZXNvdXJjZXMnLCBkZWZhdWx0OiBmYWxzZSB9KSlcbiAgICAuY29tbWFuZCgnbWV0YWRhdGEgW1NUQUNLXScsICdSZXR1cm5zIGFsbCBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGFjaycpXG4gICAgLmNvbW1hbmQoJ2luaXQgW1RFTVBMQVRFXScsICdDcmVhdGUgYSBuZXcsIGVtcHR5IENESyBwcm9qZWN0IGZyb20gYSB0ZW1wbGF0ZS4gSW52b2tlZCB3aXRob3V0IFRFTVBMQVRFLCB0aGUgYXBwIHRlbXBsYXRlIHdpbGwgYmUgdXNlZC4nLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignbGFuZ3VhZ2UnLCB7IHR5cGU6ICdzdHJpbmcnLCBhbGlhczogJ2wnLCBkZXNjOiAnVGhlIGxhbmd1YWdlIHRvIGJlIHVzZWQgZm9yIHRoZSBuZXcgcHJvamVjdCAoZGVmYXVsdCBjYW4gYmUgY29uZmlndXJlZCBpbiB+Ly5jZGsuanNvbiknLCBjaG9pY2VzOiBpbml0VGVtcGxhdGVMYW51YWdlcyB9KVxuICAgICAgLm9wdGlvbignbGlzdCcsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnTGlzdCB0aGUgYXZhaWxhYmxlIHRlbXBsYXRlcycgfSkpXG4gICAgLmNvbW1hbmREaXIoJy4uL2xpYi9jb21tYW5kcycsIHsgZXhjbHVkZTogL15fLiovIH0pXG4gICAgLnZlcnNpb24odmVyc2lvbi5ESVNQTEFZX1ZFUlNJT04pXG4gICAgLmRlbWFuZENvbW1hbmQoMSwgJycpIC8vIGp1c3QgcHJpbnQgaGVscFxuICAgIC5oZWxwKClcbiAgICAuYWxpYXMoJ2gnLCAnaGVscCcpXG4gICAgLmVwaWxvZ3VlKFtcbiAgICAgICdJZiB5b3VyIGFwcCBoYXMgYSBzaW5nbGUgc3RhY2ssIHRoZXJlIGlzIG5vIG5lZWQgdG8gc3BlY2lmeSB0aGUgc3RhY2sgbmFtZScsXG4gICAgICAnSWYgb25lIG9mIGNkay5qc29uIG9yIH4vLmNkay5qc29uIGV4aXN0cywgb3B0aW9ucyBzcGVjaWZpZWQgdGhlcmUgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHRzLiBTZXR0aW5ncyBpbiBjZGsuanNvbiB0YWtlIHByZWNlZGVuY2UuJ1xuICAgIF0uam9pbignXFxuXFxuJykpXG4gICAgLmFyZ3Y7XG59XG5cbmlmICghcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgY29sb3JzLmRpc2FibGUoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdENvbW1hbmRMaW5lKCkge1xuICBjb25zdCBhcmd2ID0gYXdhaXQgcGFyc2VDb21tYW5kTGluZUFyZ3VtZW50cygpO1xuICBpZiAoYXJndi52ZXJib3NlKSB7XG4gICAgc2V0VmVyYm9zZSgpO1xuICB9XG4gIGRlYnVnKCdDREsgdG9vbGtpdCB2ZXJzaW9uOicsIHZlcnNpb24uRElTUExBWV9WRVJTSU9OKTtcbiAgZGVidWcoJ0NvbW1hbmQgbGluZSBhcmd1bWVudHM6JywgYXJndik7XG5cbiAgY29uc3QgYXdzID0gbmV3IFNESyh7XG4gICAgcHJvZmlsZTogYXJndi5wcm9maWxlLFxuICAgIHByb3h5QWRkcmVzczogYXJndi5wcm94eSxcbiAgICBlYzJjcmVkczogYXJndi5lYzJjcmVkcyxcbiAgfSk7XG4gIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvbihhcmd2KTtcbiAgYXdhaXQgY29uZmlndXJhdGlvbi5sb2FkKCk7XG5cbiAgY29uc3QgcHJvdmlzaW9uZXIgPSBuZXcgQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50VGFyZ2V0KHsgYXdzIH0pO1xuXG4gIGNvbnN0IGFwcFN0YWNrcyA9IG5ldyBBcHBTdGFja3Moe1xuICAgIHZlcmJvc2U6IGFyZ3YudHJhY2UgfHwgYXJndi52ZXJib3NlLFxuICAgIGlnbm9yZUVycm9yczogYXJndlsnaWdub3JlLWVycm9ycyddLFxuICAgIHN0cmljdDogYXJndi5zdHJpY3QsXG4gICAgY29uZmlndXJhdGlvbixcbiAgICBhd3MsXG4gICAgc3ludGhlc2l6ZXI6IGV4ZWNQcm9ncmFtLFxuICB9KTtcblxuICAvKiogRnVuY3Rpb24gdG8gbG9hZCBwbHVnLWlucywgdXNpbmcgY29uZmlndXJhdGlvbnMgYWRkaXRpdmVseS4gKi9cbiAgZnVuY3Rpb24gbG9hZFBsdWdpbnMoLi4uc2V0dGluZ3M6IFNldHRpbmdzW10pIHtcbiAgICBjb25zdCBsb2FkZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzZXR0aW5ncykge1xuICAgICAgY29uc3QgcGx1Z2luczogc3RyaW5nW10gPSBzb3VyY2UuZ2V0KFsncGx1Z2luJ10pIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRyeVJlc29sdmUocGx1Z2luKTtcbiAgICAgICAgaWYgKGxvYWRlZC5oYXMocmVzb2x2ZWQpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGRlYnVnKGBMb2FkaW5nIHBsdWctaW46ICR7Y29sb3JzLmdyZWVuKHBsdWdpbil9IGZyb20gJHtjb2xvcnMuYmx1ZShyZXNvbHZlZCl9YCk7XG4gICAgICAgIFBsdWdpbkhvc3QuaW5zdGFuY2UubG9hZChwbHVnaW4pO1xuICAgICAgICBsb2FkZWQuYWRkKHJlc29sdmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cnlSZXNvbHZlKHBsdWdpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUocGx1Z2luKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHBsdWdpbiAke2NvbG9ycy5ncmVlbihwbHVnaW4pfTogJHtlLnN0YWNrfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHBsdWctaW46ICR7cGx1Z2lufWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRQbHVnaW5zKGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MpO1xuXG4gIGNvbnN0IGNtZCA9IGFyZ3YuX1swXTtcblxuICAvLyBCdW5kbGUgdXAgZ2xvYmFsIG9iamVjdHMgc28gdGhlIGNvbW1hbmRzIGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgY29uc3QgY29tbWFuZE9wdGlvbnMgPSB7IGFyZ3M6IGFyZ3YsIGFwcFN0YWNrcywgY29uZmlndXJhdGlvbiwgYXdzIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGFyZ3YuY29tbWFuZEhhbmRsZXJcbiAgICAgID8gYXdhaXQgKGFyZ3YuY29tbWFuZEhhbmRsZXIgYXMgKG9wdHM6IHR5cGVvZiBjb21tYW5kT3B0aW9ucykgPT4gYW55KShjb21tYW5kT3B0aW9ucylcbiAgICAgIDogYXdhaXQgbWFpbihjbWQsIGFyZ3YpO1xuICAgIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdG9Kc29uT3JZYW1sKHJldHVyblZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCB2ZXJzaW9uLmRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbWFpbihjb21tYW5kOiBzdHJpbmcsIGFyZ3M6IGFueSk6IFByb21pc2U8bnVtYmVyIHwgc3RyaW5nIHwge30gfCB2b2lkPiB7XG4gICAgY29uc3QgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nID0gY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd0b29sa2l0U3RhY2tOYW1lJ10pIHx8IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuXG4gICAgaWYgKHRvb2xraXRTdGFja05hbWUgIT09IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FKSB7XG4gICAgICBwcmludChgVG9vbGtpdCBzdGFjazogJHtjb2xvcnMuYm9sZCh0b29sa2l0U3RhY2tOYW1lKX1gKTtcbiAgICB9XG5cbiAgICBhcmdzLlNUQUNLUyA9IGFyZ3MuU1RBQ0tTIHx8IFtdO1xuICAgIGFyZ3MuRU5WSVJPTk1FTlRTID0gYXJncy5FTlZJUk9OTUVOVFMgfHwgW107XG5cbiAgICBjb25zdCBjbGkgPSBuZXcgQ2RrVG9vbGtpdCh7IGFwcFN0YWNrcywgcHJvdmlzaW9uZXIgfSk7XG5cbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ2xzJzpcbiAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpTGlzdChhcmdzLlNUQUNLUywgeyBsb25nOiBhcmdzLmxvbmcgfSk7XG5cbiAgICAgIGNhc2UgJ2RpZmYnOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpLmRpZmYoe1xuICAgICAgICAgIHN0YWNrTmFtZXM6IGFyZ3MuU1RBQ0tTLFxuICAgICAgICAgIGV4Y2x1c2l2ZWx5OiBhcmdzLmV4Y2x1c2l2ZWx5LFxuICAgICAgICAgIHRlbXBsYXRlUGF0aDogYXJncy50ZW1wbGF0ZSxcbiAgICAgICAgICBzdHJpY3Q6IGFyZ3Muc3RyaWN0LFxuICAgICAgICAgIGNvbnRleHRMaW5lczogYXJncy5jb250ZXh0TGluZXNcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2Jvb3RzdHJhcCc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlCb290c3RyYXAoYXJncy5FTlZJUk9OTUVOVFMsIHRvb2xraXRTdGFja05hbWUsIGFyZ3Mucm9sZUFybiwge1xuICAgICAgICAgIGJ1Y2tldE5hbWU6IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndG9vbGtpdEJ1Y2tldCcsICdidWNrZXROYW1lJ10pLFxuICAgICAgICAgIGttc0tleUlkOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3Rvb2xraXRCdWNrZXQnLCAna21zS2V5SWQnXSksXG4gICAgICAgICAgdGFnczogY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd0YWdzJ10pXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdkZXBsb3knOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpLmRlcGxveSh7XG4gICAgICAgICAgc3RhY2tOYW1lczogYXJncy5TVEFDS1MsXG4gICAgICAgICAgZXhjbHVzaXZlbHk6IGFyZ3MuZXhjbHVzaXZlbHksXG4gICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICByb2xlQXJuOiBhcmdzLnJvbGVBcm4sXG4gICAgICAgICAgbm90aWZpY2F0aW9uQXJuczogYXJncy5ub3RpZmljYXRpb25Bcm5zLFxuICAgICAgICAgIHJlcXVpcmVBcHByb3ZhbDogY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydyZXF1aXJlQXBwcm92YWwnXSksXG4gICAgICAgICAgY2k6IGFyZ3MuY2ksXG4gICAgICAgICAgcmV1c2VBc3NldHM6IGFyZ3NbJ2J1aWxkLWV4Y2x1ZGUnXSxcbiAgICAgICAgICB0YWdzOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3RhZ3MnXSksXG4gICAgICAgICAgc2RrOiBhd3MsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaS5kZXN0cm95KHtcbiAgICAgICAgICBzdGFja05hbWVzOiBhcmdzLlNUQUNLUyxcbiAgICAgICAgICBleGNsdXNpdmVseTogYXJncy5leGNsdXNpdmVseSxcbiAgICAgICAgICBmb3JjZTogYXJncy5mb3JjZSxcbiAgICAgICAgICByb2xlQXJuOiBhcmdzLnJvbGVBcm4sXG4gICAgICAgICAgc2RrOiBhd3MsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdzeW50aGVzaXplJzpcbiAgICAgIGNhc2UgJ3N5bnRoJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaVN5bnRoZXNpemUoYXJncy5TVEFDS1MsIGFyZ3MuZXhjbHVzaXZlbHkpO1xuXG4gICAgICBjYXNlICdtZXRhZGF0YSc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlNZXRhZGF0YShhd2FpdCBmaW5kU3RhY2soYXJncy5TVEFDSykpO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2xhbmd1YWdlJ10pO1xuICAgICAgICBpZiAoYXJncy5saXN0KSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByaW50QXZhaWxhYmxlVGVtcGxhdGVzKGxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgY2xpSW5pdChhcmdzLlRFTVBMQVRFLCBsYW5ndWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlNZXRhZGF0YShzdGFja05hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBhcHBTdGFja3Muc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHMubWFuaWZlc3QubWV0YWRhdGEgfHwge307XG4gIH1cblxuICAvKipcbiAgICogQm9vdHN0cmFwIHRoZSBDREsgVG9vbGtpdCBzdGFjayBpbiB0aGUgYWNjb3VudHMgdXNlZCBieSB0aGUgc3BlY2lmaWVkIHN0YWNrKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRHbG9icyBlbnZpcm9ubWVudCBuYW1lcyB0aGF0IG5lZWQgdG8gaGF2ZSB0b29sa2l0IHN1cHBvcnRcbiAgICogICAgICAgICAgICAgcHJvdmlzaW9uZWQsIGFzIGEgZ2xvYiBmaWx0ZXIuIElmIG5vbmUgaXMgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgIGFsbCBzdGFja3MgYXJlIGltcGxpY2l0bHkgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB0b29sa2l0U3RhY2tOYW1lIHRoZSBuYW1lIHRvIGJlIHVzZWQgZm9yIHRoZSBDREsgVG9vbGtpdCBzdGFjay5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaUJvb3RzdHJhcChlbnZpcm9ubWVudEdsb2JzOiBzdHJpbmdbXSwgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcgfCB1bmRlZmluZWQsIHByb3BzOiBCb290c3RyYXBFbnZpcm9ubWVudFByb3BzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVHdvIG1vZGVzIG9mIG9wZXJhdGlvbi5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuICctLWFwcCcgYXJndW1lbnQsIHdlIHNlbGVjdCB0aGUgZW52aXJvbm1lbnRzIGZyb20gdGhlIGFwcC4gT3RoZXJ3aXNlIHdlIGp1c3QgdGFrZSB0aGUgdXNlclxuICAgIC8vIGF0IHRoZWlyIHdvcmQgdGhhdCB0aGV5IGtub3cgdGhlIG5hbWUgb2YgdGhlIGVudmlyb25tZW50LlxuXG4gICAgY29uc3QgYXBwID0gY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudHMgPSBhcHAgPyBhd2FpdCBnbG9iRW52aXJvbm1lbnRzRnJvbVN0YWNrcyhhcHBTdGFja3MsIGVudmlyb25tZW50R2xvYnMsIGF3cykgOiBlbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMoZW52aXJvbm1lbnRHbG9icyk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbnZpcm9ubWVudHMubWFwKGFzeW5jIChlbnZpcm9ubWVudCkgPT4ge1xuICAgICAgc3VjY2VzcygnIOKPsyAgQm9vdHN0cmFwcGluZyBlbnZpcm9ubWVudCAlcy4uLicsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJvb3RzdHJhcEVudmlyb25tZW50KGVudmlyb25tZW50LCBhd3MsIHRvb2xraXRTdGFja05hbWUsIHJvbGVBcm4sIHByb3BzKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wID8gJyDinIUgIEVudmlyb25tZW50ICVzIGJvb3RzdHJhcHBlZCAobm8gY2hhbmdlcykuJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJyDinIUgIEVudmlyb25tZW50ICVzIGJvb3RzdHJhcHBlZC4nO1xuICAgICAgICBzdWNjZXNzKG1lc3NhZ2UsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoJyDinYwgIEVudmlyb25tZW50ICVzIGZhaWxlZCBib290c3RyYXBwaW5nOiAlcycsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSB0aGUgZ2l2ZW4gc2V0IG9mIHN0YWNrcyAoY2FsbGVkIHdoZW4gdGhlIHVzZXIgcnVucyAnY2RrIHN5bnRoJylcbiAgICpcbiAgICogSU5QVVQ6IFN0YWNrIG5hbWVzIGNhbiBiZSBzdXBwbGllZCB1c2luZyBhIGdsb2IgZmlsdGVyLiBJZiBubyBzdGFja3MgYXJlXG4gICAqIGdpdmVuLCBhbGwgc3RhY2tzIGZyb20gdGhlIGFwcGxpY2F0aW9uIGFyZSBpbXBsaWN0bHkgc2VsZWN0ZWQuXG4gICAqXG4gICAqIE9VVFBVVDogSWYgbW9yZSB0aGFuIG9uZSBzdGFjayBlbmRzIHVwIGJlaW5nIHNlbGVjdGVkLCBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIHNob3VsZCBiZSBzdXBwbGllZCwgd2hlcmUgdGhlIHRlbXBsYXRlcyB3aWxsIGJlIHdyaXR0ZW4uXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjbGlTeW50aGVzaXplKHN0YWNrTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZWx5OiBib29sZWFuKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBPbmx5IGF1dG9zZWxlY3QgZGVwZW5kZW5jaWVzIGlmIGl0IGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggdXNlciByZXF1ZXN0IG9yIG91dHB1dCBvcHRpb25zXG4gICAgY29uc3QgYXV0b1NlbGVjdERlcGVuZGVuY2llcyA9ICFleGNsdXNpdmVseTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3Moc3RhY2tOYW1lcywge1xuICAgICAgZXh0ZW5kOiBhdXRvU2VsZWN0RGVwZW5kZW5jaWVzID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSA6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3NcbiAgICB9KTtcblxuICAgIGFwcFN0YWNrcy5wcm9jZXNzTWV0YWRhdGEoc3RhY2tzKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gc3RhY2tzWzBdLnRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBzbGlnaHQgaGFjazsgaW4gaW50ZWcgbW9kZSB3ZSBhbGxvdyBtdWx0aXBsZSBzdGFja3MgdG8gYmUgc3ludGhlc2l6ZWQgdG8gc3Rkb3V0IHNlcXVlbnRpYWxseS5cbiAgICAvLyBUaGlzIGlzIHRvIG1ha2UgaXQgc28gdGhhdCB3ZSBjYW4gc3VwcG9ydCBtdWx0aS1zdGFjayBpbnRlZyB0ZXN0IGV4cGVjdGF0aW9ucywgd2l0aG91dCBzbyBkcmFzdGljYWxseVxuICAgIC8vIGhhdmluZyB0byBjaGFuZ2UgdGhlIHN5bnRoZXNpcyBmb3JtYXQgdGhhdCB3ZSBoYXZlIHRvIHJlcnVuIGFsbCBpbnRlZyB0ZXN0cy5cbiAgICAvL1xuICAgIC8vIEJlY2F1c2UgdGhpcyBmZWF0dXJlIGlzIG5vdCB1c2VmdWwgdG8gY29uc3VtZXJzICh0aGUgb3V0cHV0IGlzIG1pc3NpbmdcbiAgICAvLyB0aGUgc3RhY2sgbmFtZXMpLCBpdCdzIG5vdCBleHBvc2VkIGFzIGEgQ0xJIGZsYWcuIEluc3RlYWQsIGl0J3MgaGlkZGVuXG4gICAgLy8gYmVoaW5kIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgIGNvbnN0IGlzSW50ZWdNb2RlID0gcHJvY2Vzcy5lbnYuQ0RLX0lOVEVHX01PREUgPT09ICcxJztcbiAgICBpZiAoaXNJbnRlZ01vZGUpIHtcbiAgICAgIHJldHVybiBzdGFja3MubWFwKHMgPT4gcy50ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gbm90IG91dHB1dHRpbmcgdGVtcGxhdGUgdG8gc3Rkb3V0LCBsZXQncyBleHBsYWluIHRoaW5ncyB0byB0aGUgdXNlciBhIGxpdHRsZSBiaXQuLi5cbiAgICBzdWNjZXNzKGBTdWNjZXNzZnVsbHkgc3ludGhlc2l6ZWQgdG8gJHtjb2xvcnMuYmx1ZShwYXRoLnJlc29sdmUoYXBwU3RhY2tzLmFzc2VtYmx5IS5kaXJlY3RvcnkpKX1gKTtcbiAgICBwcmludChgU3VwcGx5IGEgc3RhY2sgbmFtZSAoJHtzdGFja3MubWFwKHMgPT4gY29sb3JzLmdyZWVuKHMubmFtZSkpLmpvaW4oJywgJyl9KSB0byBkaXNwbGF5IGl0cyB0ZW1wbGF0ZS5gKTtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlMaXN0KHNlbGVjdG9yczogc3RyaW5nW10sIG9wdGlvbnM6IHsgbG9uZz86IGJvb2xlYW4gfSA9IHsgfSkge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3Moc2VsZWN0b3JzLCB7IGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3MgfSk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgaW4gXCJsb25nXCIgbW9kZSwgZW1pdCB0aGUgYXJyYXkgYXMtaXMgKEpTT04vWUFNTClcbiAgICBpZiAob3B0aW9ucy5sb25nKSB7XG4gICAgICBjb25zdCBsb25nID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsb25nLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHN0YWNrLm5hbWUsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudmlyb25tZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvbmc7IC8vIHdpbGwgYmUgWUFNTCBmb3JtYXR0ZWQgb3V0cHV0XG4gICAgfVxuXG4gICAgLy8ganVzdCBwcmludCBzdGFjayBuYW1lc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBkYXRhKHN0YWNrLm5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiAwOyAvLyBleGl0LWNvZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBhIHNpbmdsZSBzdGFjayBmcm9tIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBzdGFja3NcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmRTdGFjayhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3MoW25hbWVdLCB7XG4gICAgICBleHRlbmQ6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5Ob25lXG4gICAgfSk7XG5cbiAgICAvLyBDb3VsZCBoYXZlIGJlZW4gYSBnbG9iIHNvIGNoZWNrIHRoYXQgd2UgZXZhbHVhdGVkIHRvIGV4YWN0bHkgb25lXG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgY29tbWFuZCByZXF1aXJlcyBleGFjdGx5IG9uZSBzdGFjayBhbmQgd2UgbWF0Y2hlZCBtb3JlIHRoYW4gb25lOiAke3N0YWNrcy5tYXAoeCA9PiB4Lm5hbWUpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3NbMF0ubmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSnNvbk9yWWFtbChvYmplY3Q6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZShvYmplY3QsIGFyZ3YuanNvbik7XG4gIH1cbn1cblxuaW5pdENvbW1hbmRMaW5lKClcbiAgLnRoZW4odmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCh2YWx1ZSk7XG4gICAgfVxuICB9KVxuICAuY2F0Y2goZXJyID0+IHtcbiAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgZGVidWcoZXJyLnN0YWNrKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xuIl19